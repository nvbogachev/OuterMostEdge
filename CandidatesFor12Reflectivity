import itertools

def mathem(ineq):
    r = "{}".format(ineq)
    z = ""
    for s in r:
        s = s.replace('T','').replace('\r','').replace('<','').replace('=','')
        z+=s
    return(float(sage_eval(z)))
#print mathem('T <= 1/2*sqrt(10) - 1/4*sqrt(2)')

angles = [pi/2, pi/3, pi/4, pi/6]

B = itertools.product(*[angles for i in range(5)])

A.<T> = PolynomialRing(QQ)

sols = []
CH = {}


for b in B:
    if ((b[0]+b[1]+b[2] - pi > 0) and (b[0]+b[3]+b[4] - pi > 0)):
        #G = matrix([[1, -cos(b[0]), -cos(b[1]), -cos(b[3])], [-cos(b[0]), 1, -cos(b[2]), -cos(b[4])], [-cos(b[1]), -cos(b[2]), 1, -T], [-cos(b[3]), -cos(b[4]), -T, 1]])
        G1 = matrix([[1, -cos(b[0]), -cos(b[1])], [-cos(b[0]), 1, -cos(b[2])], [-cos(b[3]), -cos(b[4]), -T]])
        G2 = matrix([[1, -cos(b[0]), -cos(b[3])], [-cos(b[0]), 1, -cos(b[4])], [-cos(b[3]), -cos(b[4]), 1]])
        G3 = matrix([[1, -cos(b[0]), -cos(b[1])], [-cos(b[0]), 1, -cos(b[2])], [-cos(b[1]), -cos(b[2]), 1]])
        
        a1 = (cos(b[1]) + cos(b[0])*cos(b[2]))/(sin(b[0])*sin(b[2]))
        a3 = (cos(b[2]) + cos(b[0])*cos(b[1]))/(sin(b[0])*sin(b[1]))
        
        a2 = (cos(b[3]) + cos(b[0])*cos(b[4]))/(sin(b[0])*sin(b[4]))
        a4 = (cos(b[4]) + cos(b[0])*cos(b[3]))/(sin(b[0])*sin(b[3]))
        
        a1s = sqrt((1-a1)/2)
        a1c = sqrt((1+a1)/2)
        
        a2s = sqrt((1-a2)/2)
        if (a2s == 0):
            print b
            print b[0]+b[3]+b[4]
        
        a2c = sqrt((1+a2)/2)
        
        a3s = sqrt((1-a3)/2)
        a3c = sqrt((1+a3)/2)
        
        a4s = sqrt((1-a4)/2)
        a4c = sqrt((1+a4)/2)
        
        A0 = tanh(ln(cot(b[0]/4)))
        if (a1s == 0):
            print 'FUCK0'
        if (a1c == 0):
            print 'FUCK1'
        if (a2s == 0):
            print 'FUCK2'
        if (a2c == 0):
            print 'FUCK3'
        lng1 = arcsinh(A0/(a1s/a1c)) + arcsinh(A0/(a2s/a2c))
        lng2 = arcsinh(A0/(a3s/a3c)) + arcsinh(A0/(a4s/a4c))
        
        l = min(lng1,lng2)
        
        T = var('T')
        eq = (- G1.det(A)/sqrt(abs(det(G2)*det(G3))) <= float(cosh(l)))
        #sols.append(solve(eq, T, solution_dict=True)[0])
        
        st = solve(eq, T, solution_dict=True)[0][0]
        #print st
        CH[(float(b[0]), float(b[1]), float(b[2]), float(b[3]), float(b[4]))] = mathem(st)
        sols.append(mathem(st))
#(b[0],b[1],b[2],b[3],b[4])
#float(b[0]), float(b[1]), float(b[2]), float(b[3]), float(b[4])
print CH[(float(pi/6), float(pi/2), float(pi/2), float(pi/2), float(pi/2))]


#print float(sorted(sols)[-1])
#(0.7853981633974483, 1.5707963267948966, 1.0471975511965976, 1.0471975511965976, 1.5707963267948966)


def log(n,r):
    m=0
    while (n%r == 0):
        n = n/r
        m+=1
    return m

def is_anis(B):
    C = 2*B
    Q = QuadraticForm(QQ,C)
    QD = Q.rational_diagonal_form()
    QDM = QD.Gram_matrix()
    
    l=0
    if (log(det(B),2)%2 == 0):
        if ( (det(B)/(2^(log(det(B),2))))%8 == 1):
            if Q.is_anisotropic(2):
                l+=1
            else:
                l = l
    else:
        for q in xrange(3,-det(B)+1):
            if is_prime(q) == True:
                if (det(B)%q == 0):
                    if Q.is_anisotropic(q):
                        l+=1
    if (l > 0):
        return True
    else:
        return False


def qform(B):
    C = 2*B
    Q = QuadraticForm(ZZ, C)
    return Q


def is_equival(B,C):
    Q1 = qform(B)
    Q2 = qform(C)
    if (Q1.is_locally_equivalent_to(Q2)):
        return True
    else:
        return False



def listofanislattices():
    k = 0
    list0 = []
    for e00 in xrange(1,3):
        for e11 in xrange(1,3):
            for e22 in xrange(1,3):
                for e33 in xrange(1,3):
                    for e01 in xrange(sqrt(e00*e11)+1):
                        for e02 in xrange(sqrt(e00*e22)+1):
                            for e03 in xrange(sqrt(e00*e33)+1):
                                for e12 in range(sqrt(e11*e22) + 1):
                                    for e13 in xrange(sqrt(e33*e11)+1):
                                        if ((e01 + e02 + e03 + e12 + e13 > 0) and (e01 < sqrt(e00*e11)) and (e02 < sqrt(e00*e22)) and (e03 < sqrt(e00*e33)) and (e12 < sqrt(e22*e11)) and (e13 < sqrt(e33*e11)) ):
                                            if (arccos(e01/sqrt(e00*e11)) + arccos(e02/sqrt(e00*e22)) + arccos(e12/sqrt(e22*e11)) - pi > 0):
                                                if (arccos(e01/sqrt(e00*e11)) + arccos(e03/sqrt(e00*e33)) + arccos(e13/sqrt(e11*e33)) - pi > 0):
                                                    for T in range(floor(1 + sqrt(e22*e33)*CH[(float(arccos(e01/sqrt(e00*e11))), float(arccos(e02/sqrt(e00*e22))), float(arccos(e12/sqrt(e22*e11))), float(arccos(e03/sqrt(e00*e33))), float(arccos(e13/sqrt(e11*e33))))])):
                                                        A = matrix([[e00,-e01,-e02,-e03],[-e01,e11,-e12,-e13],[-e02,-e12,e22,-T], [-e03,-e13,-T,e33]])
                                                        if (det(A) < 0):
                                                            if (is_anis(A) == True):
                                                                list0.append(A)
                                                                k+=1
    return list0


l1 = listofanislattices()

l = len(l1)
print l

List = []

for A in l1:
    if not any(is_equival(A, B) for B in List):
        List.append(A)
lth = len(List)
print lth
#print List



for A in List:
    print A
    print det(A)





